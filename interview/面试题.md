# 面试问题
## k8s方面
* 1.如何管理k8s集群

* 2.k8s集群如何保证高可用
```
 Kubernetes 通过心跳检测机制来确定节点是否失效。如果节点失效，Kubernetes 会自动将其上的工作负载迁移到其他可用节点。
 Kubernetes 提供了Leader 选举机制，用以确保多个控制器的实例同时运行，并且只有Leader 实例提供真正的服务
```
* 3.k8s cicd发布从开发提交代码到上线运维在每个部分起到的作用是什么我们需要关注哪些点
```
Kubernetes CICD 是指使用 Continuous Integration 和 Continuous Deployment 的方式，在 Kubernetes 集群上部署和管理应用程序。
CICD 过程通常分为以下几个部分：
开发：开发人员编写代码，并将其提交到代码仓库。
构建：构建系统从代码仓库拉取代码，并使用打包工具（如 Docker）打包应用程序。
测试：自动化测试系统对打包的应用程序进行测试，以确保代码符合质量标准。
部署：如果测试通过，应用程序将部署到 Kubernetes 集群。
运维：应用程序在生产环境中运行，运维团队负责监控和维护应用程序。
```
* 4.k8s集群中某台机器需要关机或者维护我们如何优雅的操作
```
Kubernetes 集群中 master 节点或 node 节点关机或维护时，需要保证关机/维护操作对应用程序的影响尽可能小。以下是一些优雅的操作方法：
关闭 node 节点：使用 kubectl drain 命令可以将 node 上的工作负载平滑迁移到其他 node 上。
维护 master 节点：通常可以使用多个 master 节点，在一个 master 节点上执行维护操作时，其他 master 节点可以继续提供服务。
使用可伸缩的部署方式：使用 ReplicaSet、Deployment 等可伸缩的部署方式，可以在关机/维护期间保证应用程序的正常运行。

需要注意的是，具体的优雅关机/维护操作方式可能因 Kubernetes 集群的架构、应用程序的部署方式等因素不同而有所不同。
因此，需要根据实际情况灵活选择和使用相应的操作方法。
```
* 5.k8s Flannel（基于隧道） 和 Calico （基于路由）
```
Flannel 首先创建了一个名为 flannel0 的网桥，而且这个网桥的一端连接 docker0 的网桥，另一端连接一个名为 flanneld 的服务进程。
Flanneld 进程并不简单，它首先上连 etcd，利用 etcd 来管理可分配的 IP 地址段资源，同时监控 etcd 中每个 Pod 的实际地址，
并在内存中建立了一个 Pod 节点路由表；然后下连 docker0 和物理网络，使用内存中的 Pod 节点路由表，将 docker0 发给它的数据包包装起来，
利用物理网络的连接将数据包投递到目标 flanneld 上，从而完成 pod 到 pod 之间的直接的地址通信。

Flannel 实现了对 Kubernetes 网络的支持，但是它引入了多个网络组件，在网络通信时需要转到 flannel0 网络接口，
再转到用户态的 flanneld 程序，到对端后还需要走这个过程的反过程，所以也会引入一些网络的时延损耗。
另外 Flannel 默认的底层通信协议是 UDP。UDP 本身是非可靠协议，虽然两端的 TCP 实现了可靠传输，
但在大流量、高并发应用场景下还需要反复调试，确保不会出现传输质量的问题。特别是对网络依赖重的应用，需要评估对业务的影响。


Calico 作为一款针对企业级数据中心的虚拟网络工具，借助 BGP、路由表和 iptables，实现了一个无需解包封包的三层网络，并且有调试简单的特点。
```
* 6. TPS（每秒事务数） 和qps （每秒查询率）
```
```
* 7. k8s 巨大流量时如何优雅的发布程序
```
使用部署控制器：部署控制器，如Deployment、StatefulSet、DaemonSet，可以管理Pod的生命周期和更新。
利用滚动更新：通过更新一部分Pod，再等待运行状态稳定，再更新下一部分Pod。
利用服务策略：使用Kubernetes服务策略，如滚动更新和重新导向流量，可以确保程序正常运行。
状态监控：使用监控工具，如Prometheus、Grafana等，可以查看Pod的状态，并在发生错误时立即响应。
自动回滚：通过设置Pod的生命周期钩子，可以在程序出现错误时自动回滚到上一个版本
```
8.requests 和 limits 
```
requests定义了对应容器需要的最小资源量
limits定义了这个容器最大可以消耗的资源上限，防止过量消耗资源导致资源短缺甚至宕机

节点资源不足时，会触发自动驱逐，将一些低优先级的 Pod 删除掉以释放资源让节点自愈。
没有设置 request，limit 的 Pod 优先级最低，容易被驱逐；request 不等于 limit 的其次； 
request 等于 limit 的 Pod 优先级较高，不容易被驱逐。
所以如果是重要的线上应用，不希望在节点故障时被驱逐导致线上业务受影响，
就建议将 request 和 limit 设成一致。
```
